package org.mtc.pattern.factory.multiplechild;

import org.mtc.pattern.factory.multiplechild.connectors.Connector;

/*
 * 	工厂模式：将对象的创建过程提取到一个单独的类里，将创建和使用分离，创建过程越复杂收益越大
 * 
 * 	工厂模式不易理解的好处：对多种子类的按需创建
 * 
 * 	这个好处基于良好的继承，最好是面向接口编程：
 * 	假设有一个接口，他有一大堆的实现类用于应对各种情况，那么要使用这个接口必然要面临判断该使用哪个实现类的情况，这些判断和创建必然复杂曲折，丢进工厂类里就成了好选择
 * 	一般来说如果整个项目完全自闭不与外部软件交互是很难发现工厂模式的这个优点的，但现在很少有不与外界联系的项目了，一旦项目需要连接数据库，马上就会看出工厂模式的这个优点
 * 
 * 	这个好处必须满足两点：
 * 	1.继承良好，任何一个子类都能保证父类或接口的方法的完美执行
 * 	2.子类足够多足够杂，并且根据不同情况需要不同子类
 * 
 * 	然后加上一个巨大的加分情况：
 * 	3.子类变化不可控
 */
/*
 * 	这个好处必须处于特殊的情境下才会有效，我来模拟一个数据库连接的效果
 */
public class Main {
	public static void main(String[] args) {
		
		Connector connector = ConnectorFectory.getConnector(); 
		// 因为有连接器工厂读取配置文件创建连接，这里只要一行代码就可以获取到连接器
		// 这里没有任何实际的创建连接器的代码，因此如果未来要更换连接器也不需要修改这里的代码
		// 如此一来就完成了数据库和代码的分离，避免了由于数据库的修改导致的主体代码变化
		
		System.out.println(connector.selectAll()); // 因为所有连接器都完全按照设计实现连接器接口，所以不论使用哪个连接器结果都是相同的
	}
}
