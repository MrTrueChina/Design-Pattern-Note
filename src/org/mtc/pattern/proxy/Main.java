package org.mtc.pattern.proxy;

/*
 * 	代理模式（Proxy）：在内外部类之间增加一个代理类，内部类通过代理类和需要调用的类交流，代理类用于控制访问
 * 
 * 	代理模式和装饰器模式（Decorator）、外观模式（Facade）在实现上几乎一模一样，但他们的目的各不相同
 * 	装饰器用于给现有方法加功能；外观模式用于简化外部调用；代理模式则用于控制外部对内部的访问
 * 
 * 	代理模式的演示需要一个场景，我来编一个：
 * 	互联网时代，软件连上网比不联网好赚钱的多，俗话说没有钱万万不能，为了能早日赚够钱存银行吃利息然后辞职保头发，我们要做联网的软件
 * 	要联网就离不开数据库，一般来说数据库的速度比服务器快，但服务器堆叠更简单，最后反而是服务器速度远远地超过了数据库
 * 	此时有多种办法让服务器不需要完全依赖数据库运行从而让服务器全速运行，比如，使用缓存
 */
public class Main {

}
